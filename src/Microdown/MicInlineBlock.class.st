"
I am an inline block generated by inline splitter, to parse inline text.

I am characterized by:
- start & end: locations of my opener & closer delimiters in initial string
- substring: concerned text (without delimiters so)
- kind: my type, symbol which must be the same than my relative delimiter type (#basic for normal text)
- children: array in case of nested inline blocks


"
Class {
	#name : #MicInlineBlock,
	#superclass : #MicElement,
	#instVars : [
		'start',
		'end',
		'children',
		'substring'
	],
	#category : #'Microdown-ModelInline'
}

{ #category : #constructor }
MicInlineBlock class >> from: aStartInteger to: anEndInteger withSubstring: aString [
	^ self new 
		start: aStartInteger; 
		end: anEndInteger; 
		substring: aString; 
		children: Array empty; 
		cleanSubstring; yourself.	
]

{ #category : #constructor }
MicInlineBlock class >> from: aStartInteger to: anEndInteger withSubstring: aString withChildren: aChildren [
	^ self new 
		start: aStartInteger; 
		end: anEndInteger; 
		substring: aString; 
		children: aChildren; 
		cleanSubstring; yourself.	
]

{ #category : #testing }
MicInlineBlock class >> isEvaluated [
	^ true
]

{ #category : #accessing }
MicInlineBlock >> children [
	^ children
]

{ #category : #accessing }
MicInlineBlock >> children: anArray [
	children := anArray
]

{ #category : #printing }
MicInlineBlock >> childrenPrintOn [
	^ (children asString allButFirst: 9) allButLast
]

{ #category : #operations }
MicInlineBlock >> cleanSubstring [
	self isOnlyChild ifTrue: [ 
		self substring: ( String streamContents: [:s | 
			(self substring splitOn: self escapeCharacter)
				doWithIndex: [:each :i | 
					(each isEmpty and: i>1) ifTrue: [ s << self escapeCharacter ] ifFalse: [ s << each ] ] ] ) ]
]

{ #category : #accessing }
MicInlineBlock >> end [
	^ end
]

{ #category : #accessing }
MicInlineBlock >> end: anInteger [
	end := anInteger
]

{ #category : #operations }
MicInlineBlock >> escapeCharacter [
	^ MicEscapeDelimiter markup
]

{ #category : #initialization }
MicInlineBlock >> initialize [

	super initialize. 
	children := #().
	
]

{ #category : #testing }
MicInlineBlock >> isOnlyChild [
	^ children isEmpty
]

{ #category : #accessing }
MicInlineBlock >> kind [
	"we are deprecating the state"
	^ self error
]

{ #category : #accessing }
MicInlineBlock >> literal [
	^ substring copyFrom: start to: end. 
]

{ #category : #printing }
MicInlineBlock >> printOn: aStream [

	(self kind == #basic) 
		ifTrue: [ aStream nextPutAll: self substring ] 
		ifFalse: [ 
			| contents |
			contents := children 
				ifEmpty: [ self substring ] 
				ifNotEmpty: [ self childrenPrintOn ].
			aStream nextPut: $[;
				nextPutAll: contents;
				nextPut: $];
				nextPut: $(;
				nextPutAll: self kind;
				nextPut: $) 
		]
]

{ #category : #debugging }
MicInlineBlock >> showStructure: indent [
	"Produce a string representing the structure in terms of block classes of the receiver"
	
	| ind |
	ind := String tab repeat: indent.
	^ ind, self class name, String cr, (children collect: [:c | c showStructure: indent + 1]).
]

{ #category : #accessing }
MicInlineBlock >> start [ 	
	^ start
]

{ #category : #accessing }
MicInlineBlock >> start: anInteger [
	start := anInteger 
]

{ #category : #obsolete }
MicInlineBlock >> substring [
	^ substring
]

{ #category : #obsolete }
MicInlineBlock >> substring: aSubString [
	substring := aSubString
]

{ #category : #accessing }
MicInlineBlock >> text [
 	^ substring
]
